/*
 * courier
 * 0.0.1
 * Ferris Tseng
 * 2013-08-18 05:08
 */
(function() {
    window.isFirefox = "undefined" != typeof InstallTrigger, window.isChrome = null != window.chrome && null != window.chrome.webstore;
}).call(this), function() {
    var EventEmitter, Logger, Token;
    Token = function() {
        function Token() {}
        return Token.__rand__ = function() {
            return Math.random().toString(36).substr(2);
        }, Token.generate = function() {
            return Development ? "development" : Token.__rand__() + Token.__rand__();
        }, Token;
    }(), Logger = function() {
        function Logger(cls) {
            this.cls = cls;
        }
        return Logger.prototype.log = function(msg) {
            return window.console ? console.log("" + this.cls + " -> " + msg) : void 0;
        }, Logger;
    }(), EventEmitter = function() {
        function EventEmitter() {
            this.handlers = {};
        }
        return EventEmitter.prototype.on = function(key, handler) {
            return key in this.handlers || (this.handlers[key] = []), this.handlers[key].push(handler), 
            this.handlers[key].length - 1;
        }, EventEmitter.prototype.once = function(key, handler) {
            var index, _this = this;
            return index = this.on(key, handler), this.on(key, function() {
                return _this.handlers[key].splice(index, 2);
            });
        }, EventEmitter.prototype.trigger = function() {
            return this.__execute_handlers__.apply(this, arguments);
        }, EventEmitter.prototype.__execute_handlers__ = function(key) {
            var n, _i, _len, _ref, _results;
            if (key in this.handlers) {
                for (_ref = this.handlers[key], _results = [], _i = 0, _len = _ref.length; _len > _i; _i++) n = _ref[_i], 
                _results.push(n.apply(this, Array.prototype.slice.call(arguments, 1)));
                return _results;
            }
        }, EventEmitter;
    }(), window.Token = Token, window.Logger = Logger, window.EventEmitter = EventEmitter;
}.call(this), function() {
    var FileStorage, IndexedDBFileStorage, logger, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
        function ctor() {
            this.constructor = child;
        }
        for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
        return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
        child;
    };
    logger = new Logger("FileStorage"), FileStorage = function() {
        function FileStorage() {}
        return FileStorage.prototype.storeChunk = function() {}, FileStorage.prototype.assembleChunks = function() {}, 
        FileStorage.prototype.getChunk = function() {}, FileStorage.prototype.cleanUp = function() {}, 
        FileStorage;
    }(), IndexedDBFileStorage = function(_super) {
        function IndexedDBFileStorage() {
            var _this = this;
            this.db = null, this.onready = null, this.request = indexedDB.open(IndexedDBFileStorage.DB_NAME), 
            this.request.onsuccess = function(event) {
                return _this.db = event.target.result, null != _this.onready ? _this.onready() : void 0;
            }, this.request.onupgradeneeded = function(event) {
                return _this.db = event.target.result, _this.db.createObjectStore(IndexedDBFileStorage.DB_STORE, {
                    keyPath: "id"
                }).createIndex("name", "name", {
                    unique: !1
                }), null != _this.onready ? _this.onready() : void 0;
            };
        }
        return __extends(IndexedDBFileStorage, _super), IndexedDBFileStorage.DB_NAME = "DownloadFileStorage", 
        IndexedDBFileStorage.DB_STORE = "files", IndexedDBFileStorage.prototype.getObjectStore = function(type) {
            return null == type && (type = "read"), this.db ? this.db.transaction([ IndexedDBFileStorage.DB_STORE ], type).objectStore(IndexedDBFileStorage.DB_STORE) : void 0;
        }, IndexedDBFileStorage.prototype.storeChunk = function(chunk, chunk_num, f_name, f_type, onsuccess, onerror) {
            var e, r;
            if (this.db) try {
                return r = this.getObjectStore("readwrite").add({
                    id: "" + f_name + "_" + chunk_num,
                    name: f_name,
                    chunk_num: chunk_num,
                    data: new Blob([ chunk ], {
                        type: f_type
                    })
                }), r.onsuccess = onsuccess, r.onerror = onerror;
            } catch (_error) {
                return e = _error, console.log(e);
            }
        }, IndexedDBFileStorage.prototype.getChunk = function(chunk_num, f_name, onsuccess, onerror) {
            var e, r;
            if (this.db) try {
                return r = this.getObjectStore().get("" + f_name + "_" + chunk_num), r.onsuccess = onsuccess, 
                r.onerror = onerror;
            } catch (_error) {
                return e = _error, console.log(e);
            }
        }, IndexedDBFileStorage.prototype.assembleChunks = function(f_name, f_type, onsuccess) {
            var allChunks, e, r;
            if (this.db) try {
                return r = this.getObjectStore().index("name").openCursor(IDBKeyRange.only(f_name)), 
                allChunks = [], request.onsuccess = function(event) {
                    var cursor;
                    return cursor = event.target.result, cursor ? (allChunks.push(cursor.value.data), 
                    cursor["continue"]()) : onsuccess(new Blob(allChunks, {
                        type: f_type
                    }));
                };
            } catch (_error) {
                return e = _error, console.log(e);
            }
        }, IndexedDBFileStorage.prototype.cleanUp = function() {
            return logger.log("Not yet implemented!");
        }, IndexedDBFileStorage;
    }(FileStorage), window.FileStorage = isFirefox ? new IndexedDBFileStorage() : void 0;
}.call(this), function() {
    var PrivateChannel, SignalingChannel, WebsocketChannel, logger, _ref, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
        function ctor() {
            this.constructor = child;
        }
        for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
        return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
        child;
    };
    logger = new Logger("SignalingChannel"), SignalingChannel = function(_super) {
        function SignalingChannel() {
            SignalingChannel.__super__.constructor.apply(this, arguments);
        }
        return __extends(SignalingChannel, _super), SignalingChannel.prototype.join = function() {}, 
        SignalingChannel.prototype.send = function() {}, SignalingChannel.prototype.__trigger__ = SignalingChannel.prototype.trigger, 
        SignalingChannel.prototype.trigger = function(e) {
            return logger.log("Triggered " + e + "!"), this.__trigger__.apply(this, arguments);
        }, SignalingChannel;
    }(EventEmitter), WebsocketChannel = function(_super) {
        function WebsocketChannel() {
            var _this = this;
            this.ws = new WebSocket("ws://localhost:8000"), this.ws.onopen = function() {
                return _this.__onopen__();
            }, this.ws.onmessage = function(e) {
                return _this.__onmessage__(e);
            }, this.ws.onclose = function() {
                return _this.__onclose__();
            }, WebsocketChannel.__super__.constructor.apply(this, arguments);
        }
        return __extends(WebsocketChannel, _super), WebsocketChannel.prototype.__send__ = function(event, data, callback) {
            return logger.log("Sending [event] " + event + "!"), this.ws.send(JSON.stringify({
                type: event,
                data: data
            }), callback);
        }, WebsocketChannel.prototype.__onopen__ = function() {
            return this.trigger("open");
        }, WebsocketChannel.prototype.__onmessage__ = function(event) {
            var e;
            return e = JSON.parse(event.data), logger.log("Received [event] " + e.type + "!"), 
            this.trigger("message", e), this.trigger(e.type, e.data);
        }, WebsocketChannel.prototype.__onclose__ = function() {
            return this.trigger("close");
        }, WebsocketChannel.prototype.join = function(room) {
            return this.__send__("join", room);
        }, WebsocketChannel.prototype.send = function(event, data, callback) {
            return this.__send__(event, data, callback);
        }, WebsocketChannel;
    }(SignalingChannel), PrivateChannel = function(_super) {
        function PrivateChannel() {
            return _ref = PrivateChannel.__super__.constructor.apply(this, arguments);
        }
        return __extends(PrivateChannel, _super), PrivateChannel;
    }(SignalingChannel), window.SignalingChannel = new WebsocketChannel();
}.call(this), function() {
    var ChromeRTCImplementation, FirefoxRTCImplementation, WebRTCImplementation, emptyFunction, _ref, _ref1, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
        function ctor() {
            this.constructor = child;
        }
        for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
        return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
        child;
    };
    emptyFunction = function() {}, WebRTCImplementation = function() {
        function WebRTCImplementation() {
            this.servers = {
                iceServers: [ {
                    url: "stun:stun.l.google.com:19302"
                } ]
            }, this.onicecandidate = null;
        }
        return WebRTCImplementation.handleSession = function(peer, session, callback) {
            return peer.setLocalDescription(session), callback(session);
        }, WebRTCImplementation.prototype.createPeer = function() {}, WebRTCImplementation.prototype.createChannel = function() {}, 
        WebRTCImplementation.prototype.createOffer = function() {}, WebRTCImplementation.prototype.handleOffer = function() {}, 
        WebRTCImplementation.prototype.createAnswer = function() {}, WebRTCImplementation.prototype.handleAnswer = function() {}, 
        WebRTCImplementation.prototype.addIceCandidate = function() {}, WebRTCImplementation;
    }(), FirefoxRTCImplementation = function(_super) {
        function FirefoxRTCImplementation() {
            return _ref = FirefoxRTCImplementation.__super__.constructor.apply(this, arguments);
        }
        return __extends(FirefoxRTCImplementation, _super), FirefoxRTCImplementation.mediaConstraints = {
            optional: [],
            mandatory: {
                OfferToReceiveAudio: !0,
                OfferToReceiveVideo: !0
            }
        }, FirefoxRTCImplementation.prototype.createPeer = function() {
            return new mozRTCPeerConnection(this.servers);
        }, FirefoxRTCImplementation.prototype.createChannel = function(peer, channel, options) {
            return peer.createDataChannel(channel, options);
        }, FirefoxRTCImplementation.prototype.createOffer = function(peer, callback) {
            var success;
            return success = function() {
                var offerCallback;
                return offerCallback = function(session) {
                    return WebRTCImplementation.handleSession(peer, session, callback);
                }, peer.createOffer(offerCallback, null, FirefoxRTCImplementation.mediaConstraints);
            }, navigator.mozGetUserMedia({
                audio: !0,
                fake: !0
            }, success, emptyFunction);
        }, FirefoxRTCImplementation.prototype.handleOffer = function(offer, callback) {
            var peer;
            return peer = this.createPeer(), peer.setRemoteDescription(new mozRTCSessionDescription(offer)), 
            peer.ondatachannel = function(e) {
                return peer.channel = e.channel, callback(peer.channel);
            }, peer;
        }, FirefoxRTCImplementation.prototype.createAnswer = function(peer, callback) {
            var success;
            return success = function() {
                var offerCallback;
                return offerCallback = function(session) {
                    return WebRTCImplementation.handleSession(peer, session, callback);
                }, peer.createAnswer(offerCallback, null, FirefoxRTCImplementation.mediaConstraints);
            }, navigator.mozGetUserMedia({
                audio: !0,
                fake: !0
            }, success, emptyFunction);
        }, FirefoxRTCImplementation.prototype.handleAnswer = function(peer, answer) {
            return peer.setRemoteDescription(new mozRTCSessionDescription(answer));
        }, FirefoxRTCImplementation.prototype.addIceCandidate = function(peer, candidate) {
            return peer.addIceCandidate(new mozRTCIceCandidate(candidate));
        }, FirefoxRTCImplementation;
    }(WebRTCImplementation), ChromeRTCImplementation = function(_super) {
        function ChromeRTCImplementation() {
            return _ref1 = ChromeRTCImplementation.__super__.constructor.apply(this, arguments);
        }
        return __extends(ChromeRTCImplementation, _super), ChromeRTCImplementation.config = {
            optional: [ {
                RtpDataChannels: !0
            } ]
        }, ChromeRTCImplementation.mediaConstraints = {
            optional: [],
            mandatory: {
                OfferToReceiveAudio: !1,
                OfferToReceiveVideo: !1
            }
        }, ChromeRTCImplementation.prototype.createPeer = function() {
            var peer;
            return peer = new webkitRTCPeerConnection(this.servers, ChromeRTCImplementation.config), 
            peer.onicecandidate = this.onicecandidate, peer;
        }, ChromeRTCImplementation.prototype.createChannel = function(peer, channel, options) {
            return options || (options = {}), options.reliable = !1, peer.createDataChannel(channel, options);
        }, ChromeRTCImplementation.prototype.createOffer = function(peer, callback) {
            return callback = function(session) {
                return WebRTCImplementation.handleSession(peer, session, callback);
            }, peer.createOffer(callback, null, ChromeRTCImplementation.mediaConstraints);
        }, ChromeRTCImplementation.prototype.handleOffer = function() {
            var peer;
            return peer = this.createPeer();
        }, ChromeRTCImplementation.prototype.createAnswer = function(peer, callback) {
            return callback = function(session) {
                return WebRTCImplementation.handleSession(peer, session, callback);
            }, peer.createAnswer(callback, null, ChromeRTCImplementation.mediaConstraints);
        }, ChromeRTCImplementation.prototype.handleAnswer = function(peer, answer) {
            return peer.setRemoteDescription(new RTCSessionDescription(answer));
        }, ChromeRTCImplementation.prototype.addIceCandidate = function(peer, candidate) {
            return peer.addIceCandidate(new RTCIceCandidate(candidate));
        }, ChromeRTCImplementation;
    }(WebRTCImplementation), window.WebRTCImplementation = isChrome ? new ChromeRTCImplementation() : isFirefox ? new FirefoxRTCImplementation() : void 0;
}.call(this), function() {
    var CHUNK_SIZE, ChunkedFile, Client, Host, P2PClientConnection, P2PConnection, P2PHostConnection, P2PMember, TIMEOUT, logger, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
        function ctor() {
            this.constructor = child;
        }
        for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
        return ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype, 
        child;
    };
    CHUNK_SIZE = 2097152, TIMEOUT = 6e3, logger = new Logger("P2P"), ChunkedFile = function() {
        function ChunkedFile(f, chunk_size) {
            this.f = f, this.chunk_size = chunk_size, this.name = this.f.name, this.type = this.f.type ? this.f.type : "unknown", 
            this.size = this.f.size, this.read = 0, this.chunks = parseInt(Math.ceil(this.f.size / this.chunk_size));
        }
        return ChunkedFile.prototype.slice = function(start, end) {
            return this.f.slice(start, end);
        }, ChunkedFile.prototype.getChunk = function(num) {
            return this.slice(num * CHUNK_SIZE, (num + 1) * CHUNK_SIZE);
        }, ChunkedFile.prototype.end = function() {
            return this.read === this.chunks;
        }, ChunkedFile;
    }(), P2PMember = function(_super) {
        function P2PMember() {
            var _this = this;
            FileStorage.onready = function() {
                return _this.trigger("storageReady");
            }, P2PMember.__super__.constructor.apply(this, arguments);
        }
        return __extends(P2PMember, _super), P2PMember.prototype.__trigger__ = P2PMember.prototype.trigger, 
        P2PMember.prototype.trigger = function(e) {
            return logger.log("Triggered " + e + "!"), this.__trigger__.apply(this, arguments);
        }, P2PMember;
    }(EventEmitter), P2PConnection = function(_super) {
        function P2PConnection(channel_name) {
            this.channel_name = channel_name, P2PConnection.__super__.constructor.apply(this, arguments), 
            this.peer = null, this.channel = null, this.status = 0;
        }
        return __extends(P2PConnection, _super), P2PConnection.prototype.setChannelEvents = function() {
            var _this = this;
            return this.channel.onopen = function() {
                return _this.changeStatus(4) && _this.trigger("channelOpen");
            }, this.channel.onmessage = function() {
                return _this.trigger("channelMessage");
            }, this.channel.onclose = function() {
                return _this.trigger("channelClose");
            }, this.channel.onerror = function() {
                return _this.trigger("channelError");
            };
        }, P2PConnection.prototype.changeStatus = function(s, d) {
            return this.status = s, this.trigger("statusChange#" + s, d);
        }, P2PConnection.prototype.send = function(d) {
            return this.channel && 4 === this.status ? this.channel.send(d) : void 0;
        }, P2PConnection.prototype.__trigger__ = P2PConnection.prototype.trigger, P2PConnection.prototype.trigger = function(e) {
            return logger.log("Triggered " + e + "!"), this.__trigger__.apply(this, arguments);
        }, P2PConnection;
    }(EventEmitter), P2PClientConnection = function(_super) {
        function P2PClientConnection(channel_name) {
            var _this = this;
            this.channel_name = channel_name, P2PClientConnection.__super__.constructor.apply(this, arguments), 
            this.peer = WebRTCImplementation.createPeer(), this.channel = WebRTCImplementation.createChannel(this.peer, this.channel_name), 
            this.setChannelEvents, WebRTCImplementation.createOffer(this.peer, function(o) {
                return _this.changeStatus(1, o);
            });
        }
        return __extends(P2PClientConnection, _super), P2PClientConnection.prototype.receivedAnswer = function(answer) {
            return WebRTCImplementation.handleAnswer(answer), this.changeStatus(3);
        }, P2PClientConnection;
    }(P2PConnection), P2PHostConnection = function(_super) {
        function P2PHostConnection(channel_name) {
            var _this = this;
            this.channel_name = channel_name, P2PHostConnection.__super__.constructor.apply(this, arguments), 
            SignalingChannel.on("open", function() {
                return _this.changeStatus(1), SignalingChannel.send("client#id", _this.channel_name);
            }), SignalingChannel.once("host#offer", function(offer) {
                return _this.receivedOffer(offer) && _this.changeStatus(2);
            });
        }
        return __extends(P2PHostConnection, _super), P2PHostConnection.prototype.receivedOffer = function(offer) {
            var _this = this;
            return this.peer = WebRTCImplementation.handleOffer(offer), WebRTCImplementation.createAnswer(this.peer, function(answer) {
                return _this.changeStatus(3, answer);
            });
        }, P2PHostConnection;
    }(P2PConnection), Host = function(_super) {
        function Host() {
            var _this = this;
            this.clients = {}, this.reader = new FileReader(), this.readChunk = function(start, end) {
                return this.reader.readAsArrayBuffer(this.file.slice(start, end));
            }, this.reader.onloadend = function() {
                var token;
                return _this.file.read++, _this.trigger("readProgress", _this.file.read, _this.file.chunks), 
                _this.file.end() ? (token = Token.generate(), SignalingChannel.join(token), _this.__set_event_handlers__(), 
                _this.trigger("channelJoin", token), _this.trigger("fileEnd", _this.file, token)) : _this.readChunk(_this.file.read * CHUNK_SIZE, CHUNK_SIZE * (_this.file.read + 1));
            }, Host.__super__.constructor.apply(this, arguments);
        }
        return __extends(Host, _super), Host.prototype.host = function(file) {
            return this.file = new ChunkedFile(file, CHUNK_SIZE), this.readChunk(0, CHUNK_SIZE), 
            this.file;
        }, Host.prototype.__set_event_handlers__ = function() {
            var _this = this;
            return this.on("channelJoin", function(token) {
                return SignalingChannel.send("host#id", token);
            }), SignalingChannel.on("client#new", function(c) {
                return _this.clients[c] = new P2PClientConnection(c), _this.clients[c].on("statusChange#1", function(o) {
                    return SignalingChannel.send("host#offer", {
                        client: c,
                        offer: o
                    });
                });
            }), SignalingChannel.once("client#answer", function(data) {
                return _this.clients[data.client].receivedAnswer(data.answer);
            });
        }, Host;
    }(P2PMember), Client = function(_super) {
        function Client() {
            this.id = Token.generate(), this.chunks_remaining = [], this.chunks_downloaded = [], 
            this.chunks_active = [], Client.__super__.constructor.apply(this, arguments);
        }
        return __extends(Client, _super), Client.prototype.connect = function(token) {
            return this.connection = new P2PHostConnection(this.id), this.__set_event_handlers__(token);
        }, Client.prototype.__set_event_handlers__ = function(token) {
            var _this = this;
            return this.connection.once("statusChange#1", function() {
                return SignalingChannel.join(token);
            }), this.connection.once("statusChange#3", function(answer) {
                return SignalingChannel.send("client#answer", {
                    client: _this.id,
                    answer: answer
                });
            });
        }, Client;
    }(P2PMember), window.Host = Host, window.Client = Client;
}.call(this);